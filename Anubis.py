{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "import sys import glob import serial \n",
    " import Python_Coloring from PyQt5 import QtCore from PyQt5 import QtGui from PyQt5.QtWidgets import * from PyQt5.QtCore import * from pathlib import Path \n",
    " def serial_ports(): \n",
    "    \"\"\" Lists serial port names         :raises EnvironmentError: \n",
    "            On unsupported or unknown platforms \n",
    "        :returns: \n",
    "            A list of the serial ports available on the system \n",
    "    \"\"\"     if sys.platform.startswith('win'): \n",
    "        ports = ['COM%s' % (i + 1) for i in range(256)]     elif sys.platform.startswith('linux') or sys.platform.startswith('cygwin'): \n",
    "        # this excludes your current terminal \"/dev/tty\"         ports = glob.glob('/dev/tty[A-Za-z]*')     elif sys.platform.startswith('darwin'): \n",
    "        ports = glob.glob('/dev/tty.*')     else: \n",
    "        raise EnvironmentError('Unsupported platform') \n",
    "     result = []     for port in ports: \n",
    "        try: \n",
    "            s = serial.Serial(port) \n",
    "            s.close()             result.append(port) \n",
    "\n",
    "        except (OSError, serial.SerialException): \n",
    "            pass     return result  \n",
    "\n",
    "############ Signal Class ############ \n",
    "# \n",
    "# \n",
    "# # class Signal(QObject): \n",
    " \n",
    "    # initializing a Signal which will take (string) as an input     reading = pyqtSignal(str) \n",
    " \n",
    "    # init Function for the Signal class     def __init__(self): \n",
    "        QObject.__init__(self) \n",
    " \n",
    "\n",
    "# \n",
    "############ end of Class ############ \n",
    "# \n",
    "# \n",
    " \n",
    "# Making text editor as A global variable (to solve the issue of being local to \n",
    "(self) in widget class) text = QTextEdit # cstext = QTextEdit extension = 'py' text2 = QTextEdit \n",
    " \n",
    "# \n",
    "# \n",
    "# \n",
    "# \n",
    "############ Text Widget Class ############ \n",
    "# \n",
    "# \n",
    "# \n",
    "# \n",
    "\n",
    " \n",
    "# this class is made to connect the QTab with the necessary layouts class text_widget(QWidget):     def __init__(self):         super().__init__()         self.itUI()     def itUI(self):         global text         # global cstext         global extension         extension = QTextEdit() \n",
    "        # extension.setText('py') \n",
    "                 text = QTextEdit()         cstext = QTextEdit() \n",
    "        # Python_Coloring.CsHighlighter(cstext)         Python_Coloring.Highlighter(text)         hbox = QHBoxLayout() \n",
    "        # if(extension.toPlainText()== 'py'):         hbox.addWidget(text) \n",
    "        # else: \n",
    "        #     hbox.addWidget(cstext)         self.setLayout(hbox) \n",
    " \n",
    " \n",
    "# \n",
    "# \n",
    "############ end of Class ############ \n",
    "# \n",
    "# \n",
    " \n",
    " \n",
    "\n",
    "# \n",
    "# \n",
    "############ Widget Class ############ \n",
    "# \n",
    "# \n",
    "# # class Widget(QWidget):      \n",
    " \n",
    "  def __init__(self): \n",
    "        super().__init__()         self.initUI() \n",
    "     def initUI(self): \n",
    " \n",
    "        # This widget is responsible of making Tab in IDE which makes the Text editor looks nice         tab = QTabWidget()         tx = text_widget()         tab.addTab(tx, \"Tab\"+\"1\") \n",
    " \n",
    "        # second editor in which the error messeges and succeeded connections will be shown         global text2         text2 = QTextEdit()         text2.setReadOnly(True) \n",
    "        # defining a Treeview variable to use it in showing the directory included files         self.treeview = QTreeView() \n",
    " \n",
    "        # making a variable (path) and setting it to the root path (surely I can set it to whatever the root I want, not the default) \n",
    "        #path = QDir.rootPath() \n",
    "         path = QDir.currentPath() \n",
    " \n",
    "        # making a Filesystem variable, setting its root path and applying somefilters (which I need) on it         self.dirModel = QFileSystemModel() \n",
    "        self.dirModel.setRootPath(QDir.rootPath()) \n",
    " \n",
    "        # NoDotAndDotDot => Do not list the special entries \".\" and \"..\".         # AllDirs =>List all directories; i.e. don't apply the filters to directory names. \n",
    "        # Files => List files. \n",
    "        self.dirModel.setFilter(QDir.NoDotAndDotDot | QDir.AllDirs | QDir.Files)         self.treeview.setModel(self.dirModel)         self.treeview.setRootIndex(self.dirModel.index(path))         self.treeview.clicked.connect(self.on_clicked) \n",
    " \n",
    "        vbox = QVBoxLayout()         Left_hbox = QHBoxLayout() \n",
    "        Right_hbox = QHBoxLayout()       # after defining variables of type QVBox and QHBox \n",
    "        # I will Assign treevies variable to the left one and the first text editor in which the code will be written to the right one \n",
    "        Left_hbox.addWidget(self.treeview) \n",
    "        Right_hbox.addWidget(tab) \n",
    " \n",
    "        # defining another variable of type Qwidget to set its layout as an QHBoxLayout \n",
    "        # I will do the same with the right one \n",
    "        Left_hbox_Layout = QWidget() \n",
    "        Left_hbox_Layout.setLayout(Left_hbox) \n",
    " \n",
    "        Right_hbox_Layout = QWidget() \n",
    "        Right_hbox_Layout.setLayout(Right_hbox)  \n",
    "        # I defined a splitter to seperate the two variables (left, right) and make it more easily to change the space between them \n",
    "        H_splitter = QSplitter(Qt.Horizontal) \n",
    "        H_splitter.addWidget(Left_hbox_Layout) \n",
    "        H_splitter.addWidget(Right_hbox_Layout) \n",
    "        H_splitter.setStretchFactor(1, 1) \n",
    " \n",
    "        # I defined a new splitter to seperate between the upper and lower sides of the window \n",
    "        V_splitter = QSplitter(Qt.Vertical) \n",
    "        V_splitter.addWidget(H_splitter) \n",
    "        V_splitter.addWidget(text2) \n",
    " \n",
    "        Final_Layout = QHBoxLayout(self) \n",
    "        Final_Layout.addWidget(V_splitter) \n",
    " \n",
    "        self.setLayout(Final_Layout) \n",
    " \n",
    "    # defining a new Slot (takes string) to save the text inside the first text editor \n",
    "    @pyqtSlot(str)     def Saving(s): \n",
    "                 if(extension.toPlainText()=='py'):             with open('main.py', 'w') as f:                 TEXT = text.toPlainText() \n",
    "                f.write(TEXT)         else: \n",
    "            with open('main.cs', 'w') as f:                 TEXT = text.toPlainText() \n",
    "              f.write(TEXT) \n",
    "             \n",
    "             \n",
    " \n",
    "    # defining a new Slot (takes string) to set the string to the text editor \n",
    "    @pyqtSlot(str)     def Open(s): \n",
    "        # if(extension.toPlainText()=='py'):         global text         text.setText(s) \n",
    "        # else: \n",
    "            # global cstext \n",
    "            # cstext.setText(s) \n",
    "     def on_clicked(self, index): \n",
    "         nn = self.sender().model().filePath(index)         nn = tuple([nn]) \n",
    "         if nn[0]: \n",
    "            # print(nn[0])             extension.setText(nn[0][-2:])             print(extension.toPlainText())             f = open(nn[0],'r')             with f: \n",
    "                data = f.read()                 if(extension.toPlainText()=='py' or extension.toPlainText()=='cs'): \n",
    "                    Python_Coloring.setExtension(extension.toPlainText())                     text.setText(data) \n",
    "                # else: \n",
    "                #     cstext.setText(data) \n",
    "                # self.initUI() \n",
    "# \n",
    "# \n",
    "############ end of Class ############ \n",
    "# \n",
    "# \n",
    " \n",
    "# defining a new Slot (takes string) \n",
    "# Actually I could connect the (mainwindow) class directly to the (widget class) but I've made this function in between for futuer use \n",
    "# All what it do is to take the (input string) and establish a connection with \n",
    "the widget class, send the string to it \n",
    "@pyqtSlot(str) \n",
    "def reading(s): \n",
    "    b = Signal() \n",
    "    b.reading.connect(Widget.Saving) \n",
    "    b.reading.emit(s) \n",
    " \n",
    "# same as reading Function \n",
    "@pyqtSlot(str) def Openning(s):     b = Signal() \n",
    "    b.reading.connect(Widget.Open) \n",
    "    b.reading.emit(s) \n",
    "# \n",
    "# \n",
    "# \n",
    "# \n",
    "############ MainWindow Class ############ \n",
    "# \n",
    "# \n",
    "# # class UI(QMainWindow):     def __init__(self):         super().__init__()         self.intUI() \n",
    "     def intUI(self): \n",
    "        self.port_flag = 1         self.b = Signal() \n",
    "         self.Open_Signal = Signal()  \n",
    "        # connecting (self.Open_Signal) with Openning function         self.Open_Signal.reading.connect(Openning) \n",
    " \n",
    "        # connecting (self.b) with reading function         self.b.reading.connect(reading) \n",
    " \n",
    "        # creating menu items         menu = self.menuBar() \n",
    " \n",
    "        # I have three menu items         filemenu = menu.addMenu('File') \n",
    "        Port = menu.addMenu('Port') \n",
    "        Run = menu.addMenu('Run') \n",
    " \n",
    " \n",
    "\n",
    "        # As any PC or laptop have many ports, so I need to list them to the User         # so I made (Port_Action) to add the Ports got from (serial_ports()) function \n",
    "        # copyrights of serial_ports() function goes back to a guy from stackoverflow(whome I can't remember his name), so thank you (unknown)         Port_Action = QMenu('port', self) \n",
    "         res = serial_ports() \n",
    "         for i in range(len(res)): \n",
    "            s = res[i] \n",
    "            Port_Action.addAction(s, self.PortClicked) \n",
    " \n",
    "        # adding the menu which I made to the original (Port menu) \n",
    "        Port.addMenu(Port_Action) \n",
    " \n",
    "#        Port_Action.triggered.connect(self.Port) \n",
    "#        Port.addAction(Port_Action)  \n",
    "        # Making and adding Run Actions \n",
    "        RunAction = QAction(\"Run\", self) \n",
    "        RunAction.triggered.connect(self.Run) \n",
    "        Run.addAction(RunAction) \n",
    " \n",
    "        # Making and adding File Features \n",
    "        Save_Action = QAction(\"Save\", self) \n",
    "        Save_Action.triggered.connect(self.save) \n",
    "        Save_Action.setShortcut(\"Ctrl+S\") \n",
    "        Close_Action = QAction(\"Close\", self) \n",
    "        Close_Action.setShortcut(\"Alt+c\") \n",
    "        Close_Action.triggered.connect(self.close) \n",
    "        Open_Action = QAction(\"Open\", self) \n",
    "        Open_Action.setShortcut(\"Ctrl+O\") \n",
    "        Open_Action.triggered.connect(self.open) \n",
    " \n",
    "        filemenu.addAction(Save_Action)         filemenu.addAction(Close_Action)         filemenu.addAction(Open_Action)  \n",
    "        # Seting the window Geometry         self.setGeometry(200, 150, 600, 500)         self.setWindowTitle('Anubis IDE')         self.setWindowIcon(QtGui.QIcon('Anubis.png')) \n",
    "\n",
    "         \n",
    "         widget = Widget() \n",
    "         self.setCentralWidget(widget)         self.show() \n",
    " \n",
    "    ###########################        Start OF the Functions          ##################     def Run(self):         if self.port_flag == 0: \n",
    "            mytext = text.toPlainText() \n",
    "        # \n",
    "        ##### Compiler Part \n",
    "        # \n",
    "#            ide.create_file(mytext) #            ide.upload_file(self.portNo)             text2.append(\"Sorry, there is no attached compiler.\") \n",
    "         else: \n",
    "            text2.append(\"Please Select Your Port Number First\")  \n",
    "    # this function is made to get which port was selected by the user \n",
    "    @QtCore.pyqtSlot()     def PortClicked(self): \n",
    "        action = self.sender()         self.portNo = action.text()         self.port_flag = 0 \n",
    " \n",
    " \n",
    "    # I made this function to save the code into a file     def save(self): \n",
    "        self.b.reading.emit(\"name\")  \n",
    "    # I made this function to open a file and exhibits it to the user in a text editor     def open(self): \n",
    "        file_name = QFileDialog.getOpenFileName(self,'Open File','/home') \n",
    "         if file_name[0]: \n",
    "            f = open(file_name[0],'r')             with f: \n",
    "                data = f.read()             self.Open_Signal.reading.emit(data)  \n",
    "# \n",
    "# \n",
    "############ end of Class ############ # \n",
    "#  if __name__ == '__main__': \n",
    "    app = QApplication(sys.argv)     ex = UI()     # ex = Widget()     sys.exit(app.exec_())  \n"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.3"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
